<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi-Yellow</title>
  
  <subtitle>为之则易，不为则难！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-22T02:17:14.420Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>风之行</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>@Autowired和@Resource的区别</title>
    <link href="http://yoursite.com/2019/01/22/@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/01/22/@Autowired和@Resource的区别/</id>
    <published>2019-01-22T01:33:41.000Z</published>
    <updated>2019-01-22T02:17:14.420Z</updated>
    
    <content type="html"><![CDATA[<hr><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h3 id="一、共同点"><a href="#一、共同点" class="headerlink" title="一、共同点"></a>一、共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><h3 id="二、不同点"><a href="#二、不同点" class="headerlink" title="二、不同点"></a>二、不同点</h3><h4 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1 @Autowired"></a>2.1 @Autowired</h4><p>1、@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired，只按照byType注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestServiceImpl &#123;</span><br><span class="line">    // 下面两种@Autowired只要使用一种即可</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">@Autowired</span><br><span class="line">public void setUserDao(UserDao userDao) &#123;  // 用于属性的方法上</span><br><span class="line">this.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestServiceImpl &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userDao&quot;)</span><br><span class="line">    private UserDao userDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Resource"><a href="#2-2-Resource" class="headerlink" title="2.2 @Resource"></a>2.2 @Resource</h4><p>1、@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestServiceImpl &#123;</span><br><span class="line">    // 下面两种@Resource只要使用一种即可</span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">@Resource(name=&quot;userDao&quot;)</span><br><span class="line">public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上</span><br><span class="line">    this.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入。@Resource有两个重要的属性，分别是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>3、@Resource装配顺序</p><ul><li><p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常；</p></li><li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常；</p></li><li><p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常；</p></li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。&lt;/p&gt;
&lt;h3 id=&quot;一、共同点&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springmvc" scheme="http://yoursite.com/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>Filter和Interceptor区别</title>
    <link href="http://yoursite.com/2019/01/18/Filter%E5%92%8CInterceptor%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/01/18/Filter和Interceptor区别/</id>
    <published>2019-01-18T11:34:23.000Z</published>
    <updated>2019-01-18T13:11:37.072Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、过滤器（Filter）"><a href="#一、过滤器（Filter）" class="headerlink" title="一、过滤器（Filter）"></a>一、过滤器（Filter）</h3><h4 id="1-1-作用："><a href="#1-1-作用：" class="headerlink" title="1.1 作用："></a>1.1 作用：</h4><ul><li><p>在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作；</p></li><li><p>在过滤器中修改字符编码（CharacterEncodingFilter）；</p></li><li>在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。</li></ul><h4 id="1-2-特点："><a href="#1-2-特点：" class="headerlink" title="1.2 特点："></a>1.2 特点：</h4><ul><li><p>依赖于servlet容器，在实现上，基于函数回调；</p></li><li><p>可以对几乎所有请求进行过滤；</p></li><li><p>过滤器实例只在初始化的时候调用一次。由web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。</p></li></ul><h4 id="1-3-在web-xml配置"><a href="#1-3-在web-xml配置" class="headerlink" title="1.3 在web.xml配置"></a>1.3 在web.xml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">    &lt;servlet-name&gt;/*&lt;/servlet-name&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h4 id="1-4-通过实现Filter接口实现"><a href="#1-4-通过实现Filter接口实现" class="headerlink" title="1.4 通过实现Filter接口实现"></a>1.4 通过实现Filter接口实现</h4><p>1、Servlet 的 Filter 接口需要实现如下方法：</p><ul><li><code>void init(FilterConfig paramFilterConfig)</code> – 当容器初始化 Filter 时调用，该方法在 Filter 的生命周期只会被调用一次，一般在该方法中初始化一些资源，FilterConfig 是容器提供给 Filter 的初始化参数，在该方法中可以抛出 ServletException 。init 方法必须执行成功，否则 Filter 可能不起作用，出现以下两种情况时，web 容器中 Filter 可能无效： 1）抛出 ServletException 2）超过 web 容器定义的执行时间。</li><li><code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code> – Web 容器每一次请求都会调用该方法。该方法将容器的请求和响应作为参数传递进来， FilterChain 用来调用下一个 Filter。</li><li><code>void destroy()</code> – 当容器销毁 Filter 实例时调用该方法，可以在方法中销毁资源，该方法在 Filter 的生命周期只会被调用一次。</li></ul><p>2、代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">    System.out.println(&quot;filter destroy&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line">    System.out.println(&quot;filter doFilter before&quot;);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(&quot;filter doFilter after&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">    System.out.println(&quot;filter init&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、拦截器（Interceptor）"><a href="#二、拦截器（Interceptor）" class="headerlink" title="二、拦截器（Interceptor）"></a>二、拦截器（Interceptor）</h3><h4 id="2-1-作用："><a href="#2-1-作用：" class="headerlink" title="2.1 作用："></a>2.1 作用：</h4><ul><li>拦截用户请求，进行处理。比如判断用户登录情况，权限验证。</li></ul><h4 id="2-2-特点："><a href="#2-2-特点：" class="headerlink" title="2.2 特点："></a>2.2 特点：</h4><ul><li>基于java的反射机制；</li><li>通过HandlerInterceptor接口或者继承HandlerInterceptorAdapter实现；</li><li><p>一个拦截器实例在一个controller生命周期之内可以多次调用；</p></li><li><p>属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作；</p></li><li>只能对controller请求进行拦截，对一些静态资源无法拦截；</li><li>拦截器将很多功能从我们的Action中独立出来，大量减少了我们Action的代码，独立出来的行为就有很好的重用性。</li></ul><h4 id="2-3-在web-xml配置"><a href="#2-3-在web-xml配置" class="headerlink" title="2.3 在web.xml配置"></a>2.3 在web.xml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot; /&gt;</span><br><span class="line">        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.LoginInterceptor&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot; /&gt;</span><br><span class="line">        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.AuthInterceptor&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h4 id="2-4-通过实现HandlerInterceptor接口"><a href="#2-4-通过实现HandlerInterceptor接口" class="headerlink" title="2.4 通过实现HandlerInterceptor接口"></a>2.4 通过实现HandlerInterceptor接口</h4><p>1、Spring 中主要通过 HandlerInterceptor 接口来实现请求的拦截，实现 HandlerInterceptor 接口需要实现下面三个方法：</p><ul><li>preHandle是在请求到达Controller之前实现，可进行用户校验登录等操作，返回true后，请求到达Controller层；</li><li>postHandle方法是在执行完Controller层代码之后，DispatcherServlet进行视图的渲染之前执行，因此可以对ModelAndView 对象进行处理；</li><li>afterCompletion方法是在DispatcherServlet进行视图的渲染之后执行调用，主要是进行一些资源清理等工作。</li></ul><p>2、代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;preHandle&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;postHandle&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、-拦截器（Interceptor）和过滤器（Filter）的区别"><a href="#三、-拦截器（Interceptor）和过滤器（Filter）的区别" class="headerlink" title="三、 拦截器（Interceptor）和过滤器（Filter）的区别"></a>三、 拦截器（Interceptor）和过滤器（Filter）的区别</h3><h4 id="3-1-Filter和Interceptor的区别"><a href="#3-1-Filter和Interceptor的区别" class="headerlink" title="3.1 Filter和Interceptor的区别"></a>3.1 Filter和Interceptor的区别</h4><ul><li>Filter是基于函数回调（doFilter()方法）的，而Interceptor则是基于Java反射的（AOP思想）。</li><li>Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器。</li><li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li><li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li><li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li></ul><h4 id="3-2-拦截器和过滤器执行顺序"><a href="#3-2-拦截器和过滤器执行顺序" class="headerlink" title="3.2 拦截器和过滤器执行顺序"></a>3.2 拦截器和过滤器执行顺序</h4><p>1、Filter.init();<br>2、Filter.doFilter(); before doFilter<br>3、HandlerInterceptor.preHandle();<br>4、Controller方法执行<br>5、HandlerInterceptor.postHandle();<br>6、DispatcherServlet视图渲染<br>7、HandlerInterceptor.afterCompletion();<br>8、Filter.doFilter(); after doFilter<br>9、Filter.destroy();</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、过滤器（Filter）&quot;&gt;&lt;a href=&quot;#一、过滤器（Filter）&quot; class=&quot;headerlink&quot; title=&quot;一、过滤器（Filter）&quot;&gt;&lt;/a&gt;一、过滤器（Filter）&lt;/h3&gt;&lt;h4 id=&quot;1-1-作用：&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springmvc" scheme="http://yoursite.com/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC工作原理</title>
    <link href="http://yoursite.com/2019/01/18/SpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/18/SpringMVC工作原理/</id>
    <published>2019-01-18T04:12:28.000Z</published>
    <updated>2019-01-18T04:55:50.847Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、MVC模式"><a href="#一、MVC模式" class="headerlink" title="一、MVC模式"></a>一、MVC模式</h3><h4 id="1-1-MVC的原理图："><a href="#1-1-MVC的原理图：" class="headerlink" title="1.1 MVC的原理图："></a>1.1 MVC的原理图：</h4><p><img src="https://img-blog.csdnimg.cn/20190118124807620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="mvc"></p><h4 id="1-2-分析："><a href="#1-2-分析：" class="headerlink" title="1.2 分析："></a>1.2 分析：</h4><ul><li>M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）</li><li>V-View 视图（做界面的展示  jsp，html……）</li><li>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）</li></ul><h3 id="二、SpringMVC"><a href="#二、SpringMVC" class="headerlink" title="二、SpringMVC"></a>二、SpringMVC</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合。springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。</p><h4 id="2-2-SpringMVC的原理图："><a href="#2-2-SpringMVC的原理图：" class="headerlink" title="2.2 SpringMVC的原理图："></a>2.2 SpringMVC的原理图：</h4><p><img src="https://img-blog.csdnimg.cn/20190118124848841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="springmvc"></p><h4 id="2-3-SpringMVC流程"><a href="#2-3-SpringMVC流程" class="headerlink" title="2.3 SpringMVC流程"></a>2.3 SpringMVC流程</h4><p>(1) 用户发送请求至前端控制器DispatcherServlet；</p><p>(2) DispatcherServlet收到请求调用HandlerMapping处理器映射器；</p><p>(3) 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</p><p>(4) DispatcherServlet调用HandlerAdapter处理器适配器；</p><p>(5) HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)；</p><p>(6) Controller执行完成返回ModelAndView；</p><p>(7) HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet；</p><p>(8) DispatcherServlet将ModelAndView传给ViewReslover视图解析器；</p><p>(9) ViewReslover解析后返回具体View；</p><p>(10) DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）；</p><p>(11) DispatcherServlet响应用户。</p><h4 id="2-4-组件说明："><a href="#2-4-组件说明：" class="headerlink" title="2.4 组件说明："></a>2.4 组件说明：</h4><p>(1) 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</p><p><strong>作用：</strong>接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p><p>(2)处理器映射器HandlerMapping(不需要工程师开发),由框架提供</p><p><strong>作用：</strong>根据请求的url查找Handler。<br>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p>(3)处理器适配器HandlerAdapter</p><p><strong>作用：</strong>按照特定规则（HandlerAdapter要求的规则）去执行Handler。<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p>(4) 处理器Handler(需要工程师开发)</p><p><strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong><br><strong>作用：</strong>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p><p>(5) 视图解析器View resolver(不需要工程师开发),由框架提供<br><strong>作用：</strong>进行视图解析，根据逻辑视图名解析成真正的视图（view）。</p><p>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p>(6) 视图View(需要工程师开发jsp…)</p><p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p><h5 id="2-4-1-核心架构的具体流程步骤如下："><a href="#2-4-1-核心架构的具体流程步骤如下：" class="headerlink" title="2.4.1 核心架构的具体流程步骤如下："></a>2.4.1 核心架构的具体流程步骤如下：</h5><p><strong>(1) 首先用户发送请求——&gt;DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；<br><strong>(2) DispatcherServlet——&gt;HandlerMapping</strong>， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；<br><strong>(3) DispatcherServlet——&gt;HandlerAdapter</strong>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；<br><strong>(4) HandlerAdapter——&gt;处理器功能处理方法的调用</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；<br><strong>(5) ModelAndView的逻辑视图名——&gt; ViewResolver</strong>， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；<br><strong>(6) View——&gt;渲染</strong>，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；<br><strong>(7)</strong>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><h5 id="2-4-2-下边两个组件通常情况下需要开发："><a href="#2-4-2-下边两个组件通常情况下需要开发：" class="headerlink" title="2.4.2 下边两个组件通常情况下需要开发："></a>2.4.2 下边两个组件通常情况下需要开发：</h5><ul><li><p>Handler：处理器，即后端控制器用controller表示。</p></li><li><p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、MVC模式&quot;&gt;&lt;a href=&quot;#一、MVC模式&quot; class=&quot;headerlink&quot; title=&quot;一、MVC模式&quot;&gt;&lt;/a&gt;一、MVC模式&lt;/h3&gt;&lt;h4 id=&quot;1-1-MVC的原理图：&quot;&gt;&lt;a href=&quot;#1-1-MVC的原理图：&quot; cl
      
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
    
      <category term="springmvc" scheme="http://yoursite.com/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>远程连接数据库用户权限问题</title>
    <link href="http://yoursite.com/2019/01/16/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/16/远程连接数据库用户权限问题/</id>
    <published>2019-01-16T10:30:56.000Z</published>
    <updated>2019-01-16T10:54:25.531Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、错误描述："><a href="#一、错误描述：" class="headerlink" title="一、错误描述："></a>一、错误描述：</h3><p>远程连接Mysql服务器的数据库，错误代码是1130，<strong>ERROR 1130: Host xxx.xxx.xxx.xxx  is not allowed to connect to this MySQL server</strong>  </p><h3 id="二、解决方案："><a href="#二、解决方案：" class="headerlink" title="二、解决方案："></a>二、解决方案：</h3><p>该错误应该是由远程连接的用户权限问题引起的，在本机登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称’%’即可 。 </p><h4 id="2-1-具体解决方案："><a href="#2-1-具体解决方案：" class="headerlink" title="2.1 具体解决方案："></a>2.1 具体解决方案：</h4><p>1、以权限用户root登录；</p><p><code>mysql -u root -p</code>  </p><p>2、选择mysql库 ；</p><p><code>mysql&gt; use mysql;</code> </p><p>3、查看mysql库中的user表的host值（即可进行连接访问的主机/IP名称）；</p><p><code>mysql&gt; select &#39;host&#39; from user where user=&#39;root&#39;;</code>  </p><p>4、修改host值（以通配符%的内容增加主机/IP地址），当然也可以直接增加IP地址  </p><p>如果这步出先错误为: <strong>“ERROR 1062 (23000): Duplicate entry ‘%-root’ for key ‘PRIMARY’ “</strong>  由说明该记录有了，跳过这步；</p><p><code>mysql&gt; update user set host = &#39;%&#39; where user =&#39;root&#39;;</code>  </p><p>5、刷新MySQL的系统权限相关表  ；</p><p><code>mysql&gt; flush privileges;</code>  </p><p>6、再重新查看user表时，有修改；</p><p><code>mysql&gt; select &#39;host&#39;   from user where user=&#39;root&#39;;</code>    </p><p>7、重起mysql服务即可完成。 </p><p><code>mysql&gt; net start mysql</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、错误描述：&quot;&gt;&lt;a href=&quot;#一、错误描述：&quot; class=&quot;headerlink&quot; title=&quot;一、错误描述：&quot;&gt;&lt;/a&gt;一、错误描述：&lt;/h3&gt;&lt;p&gt;远程连接Mysql服务器的数据库，错误代码是1130，&lt;strong&gt;ERROR 1130
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装</title>
    <link href="http://yoursite.com/2019/01/16/Redis%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/16/Redis安装/</id>
    <published>2019-01-16T10:12:56.000Z</published>
    <updated>2019-01-16T10:23:47.487Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、Redis安装步骤："><a href="#一、Redis安装步骤：" class="headerlink" title="一、Redis安装步骤："></a>一、Redis安装步骤：</h3><p>1、运行：<code>redis-server.exe redis.windows.conf</code>；</p><p>2、另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了，</p><p>切换到redis目录下运行 <code>redis-cli.exe -h 127.0.0.1 -p 6379</code>；</p><p>3、设置键值对 <code>set myKey abc</code>；</p><p>4、取出键值对 <code>get myKey</code> ；</p><h4 id="二、设置Redis服务命令："><a href="#二、设置Redis服务命令：" class="headerlink" title="二、设置Redis服务命令："></a>二、设置Redis服务命令：</h4><p>1、<code>redis-server --service-install redis.windows-service.conf --loglevel verbose</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、Redis安装步骤：&quot;&gt;&lt;a href=&quot;#一、Redis安装步骤：&quot; class=&quot;headerlink&quot; title=&quot;一、Redis安装步骤：&quot;&gt;&lt;/a&gt;一、Redis安装步骤：&lt;/h3&gt;&lt;p&gt;1、运行：&lt;code&gt;redis-server.e
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>传能光纤链路状态检测系统</title>
    <link href="http://yoursite.com/2019/01/16/%E4%BC%A0%E8%83%BD%E5%85%89%E7%BA%A4%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/01/16/传能光纤链路状态检测系统/</id>
    <published>2019-01-16T00:44:06.000Z</published>
    <updated>2019-01-17T11:24:30.299Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、javaweb知识点总结"><a href="#一、javaweb知识点总结" class="headerlink" title="一、javaweb知识点总结"></a>一、javaweb知识点总结</h3><h4 id="1-1-常见的java调用python脚本两种方式"><a href="#1-1-常见的java调用python脚本两种方式" class="headerlink" title="1.1 常见的java调用python脚本两种方式"></a>1.1 常见的java调用python脚本两种方式</h4><ul><li>通过jython.jar提供的类库实现</li><li>通过Runtime.getRuntime()开启进程来执行脚本文件</li></ul><h4 id="1-2-java调用python程序实现web服务功能"><a href="#1-2-java调用python程序实现web服务功能" class="headerlink" title="1.2 java调用python程序实现web服务功能"></a>1.2 java调用python程序实现web服务功能</h4><p>使用Runtime.getRuntime()执行脚本文件，这种方式和cmd中使用python+文件名的命令调用python程序相同。</p><p><strong>1、配置文件resource.properties</strong></p><p><img src="https://img-blog.csdnimg.cn/20190117192055350.png" alt="resource"></p><p><strong>2、工具类TestUtils</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtils &#123;</span><br><span class="line">public static int JavaTransferPython(String PythonPath,String FilePath) &#123;</span><br><span class="line">final String PYTHON_PATH = PythonPath;  //python.exe可执行文件的存放路径</span><br><span class="line">final String FILE_PATH = FilePath;      //test.py程序的存放路径</span><br><span class="line">String result=&quot;&quot;;</span><br><span class="line">Process proc;</span><br><span class="line">try &#123;</span><br><span class="line">String [] cmd =new String []&#123;PYTHON_PATH,FILE_PATH&#125;;</span><br><span class="line">proc = Runtime.getRuntime().exec(cmd);// 执行py文件</span><br><span class="line">            //用输入输出流来截取结果</span><br><span class="line">BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream()));</span><br><span class="line">String line = null;</span><br><span class="line">while ((line = in.readLine()) != null) &#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">proc.waitFor();   //在此需要注意的一点，java代码中的proc.waitFor()值为0表示我们调用python脚本成功，返回值为1表示调用python脚本失败，这和我们通常意义上见到的0与1定义正好相反。</span><br><span class="line">            return 1;        //因为web工程是请求-响应式的，只有请求而无响应，会报400错误。此处请求成功，返回1。</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return 0;        //请求失败，返回0。</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return 0;        //请求失败，返回0。</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、service层中定义方法名</strong></p><p><code>public int JavaTransferPythonTest();</code></p><p><strong>4、serviceImpl实现类中实现该方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;PYTHON_PATH&#125;&quot;)</span><br><span class="line">private String PYTHON_PATH;</span><br><span class="line">@Value(&quot;$&#123;FILE_PATH&#125;&quot;)</span><br><span class="line">private String FILE_PATH;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int JavaTransferPythonTest() &#123;</span><br><span class="line">return TestUtils.JavaTransferPython(PYTHON_PATH,FILE_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、action层</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/javaTransferPythonTest&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public int JavaTransferPythonTest() &#123;</span><br><span class="line">return fiberLossService.JavaTransferPythonTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、jsp渲染</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">text:&apos;&lt;font size=&quot;4&quot; face=&quot;arial&quot; color=&quot;red&quot;&gt;&lt;b&gt;执行程序&lt;/b&gt;&lt;/font&gt;&apos;,</span><br><span class="line">handler: function()&#123;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: &quot;###/javaTransferPythonTest.action&quot;,</span><br><span class="line">type:&quot;POST&quot;,    </span><br><span class="line">traditional:true,   //设置为传统方式传送参数</span><br><span class="line">success: function(html)&#123;</span><br><span class="line">if(html&gt;0)&#123;</span><br><span class="line">alert(&quot;恭喜您 ，操作成功，请到执行结果界面查看详细信息！&quot;);</span><br><span class="line">$(&quot;#dg&quot;).datagrid(&quot;reload&quot;);   //重新刷新页面</span><br><span class="line">&#125;else&#123;</span><br><span class="line">alert(&quot;对不起 ，操作失败！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、jsp搜索功能</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#ss&apos;).searchbox(&#123; </span><br><span class="line">searcher:function(value,name)&#123; </span><br><span class="line">if(name==&apos;Id&apos;)&#123;</span><br><span class="line">$(&apos;#dg&apos;).datagrid(&apos;load&apos;,&#123;</span><br><span class="line">Id:value    //&apos;%&apos;+value+&apos;%&apos;对应数据库字段为String类型,value对应数据库字段为int类型</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if(name==&apos;name&apos;)&#123;</span><br><span class="line">$(&apos;#dg&apos;).datagrid(&apos;load&apos;,&#123;</span><br><span class="line">name:value//&apos;%&apos;+value+&apos;%&apos;对应数据库字段为String类型,value对应数据库字段为int类型</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">width:250, </span><br><span class="line">menu:&apos;#mm&apos;, </span><br><span class="line">prompt:&apos;请输入搜索内容&apos; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>8、Mapper.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectPageListUseDyc&quot; parameterType=&quot;page&quot; resultMap=&quot;###&quot; &gt;</span><br><span class="line">SELECT * ### </span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;if test=&quot;paramEntity.index!=null&quot;&gt;and `index` = #&#123;paramEntity.index&#125;&lt;/if&gt;    &lt;!-- 字段index和数据库的index关键字同名，故改为`index`。index字段若为int型，可以用 = 或者like；若为String型，用like--&gt;</span><br><span class="line">&lt;/where&gt; </span><br><span class="line">limit #&#123;start&#125;,#&#123;rows&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>9、SQLyog 导出数据库</strong></p><p><img src="https://img-blog.csdnimg.cn/20190117192240356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="sql"></p><p><strong>注意：</strong>导出数据库是应该按图中标记所设置，以便重新导入该数据库时，无法导入！！！</p><p><strong>10、Tomcat做图片服务器</strong></p><ul><li><p>Tomcat作为项目服务器时因为权限问题，只能访问Tomcat文件夹下的资源。但是实际工作中如果把所有图片文件都保存在tomcat下，不利于后续工作进行。所以可以在server.xml中加入如下配置，即可访问指定的文件。</p></li><li><p>Tomcat 7.0\conf\server.xml 找到Host标签加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context docBase = &quot;D://objimgs//upload&quot; path = &quot;objimgs&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>path为访问名称，docBase为目标文件夹路径。所以 “<a href="http://127.0.0.1:8080/objimgs/test.jpg" target="_blank" rel="noopener">http://127.0.0.1:8080/objimgs/test.jpg</a>“ 即相当于访问服务器 “D://objimgs//upload/test.jpg” 文件。</p></li><li><p>效果如下：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190117192338463.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="test"></p><h4 id="2-1-python拼接图片"><a href="#2-1-python拼接图片" class="headerlink" title="2.1 python拼接图片"></a>2.1 python拼接图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import PIL.Image as Image</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#定义图像拼接函数</span><br><span class="line">def image_compose():</span><br><span class="line">    to_image = Image.new(&apos;RGB&apos;, (IMAGE_COLUMN * IMAGE_SIZE, IMAGE_ROW * IMAGE_SIZE))  # 创建一个新图循环遍历，把每张图片按顺序粘贴到对应位置上</span><br><span class="line">    for y in range(1, IMAGE_ROW + 1):</span><br><span class="line">        for x in range(1, IMAGE_COLUMN + 1):</span><br><span class="line">            from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize(</span><br><span class="line">                (IMAGE_SIZE, IMAGE_SIZE), Image.ANTIALIAS)</span><br><span class="line">            to_image.paste(from_image, ((x - 1) * IMAGE_SIZE, (y - 1) * IMAGE_SIZE))</span><br><span class="line">    return to_image.save(IMAGE_SAVE_PATH)  # 保存新图</span><br><span class="line"></span><br><span class="line">IMAGES_PATH = &apos;###&apos;  # 图片集地址</span><br><span class="line">IMAGES_FORMAT = [ &apos;.png&apos;]  # 图片格式</span><br><span class="line">IMAGE_SIZE = 600  # 每张小图片的大小     600=1200 * 600</span><br><span class="line">IMAGE_ROW = 1  # 图片间隔，也就是合并成一张图后，一共有几行</span><br><span class="line">IMAGE_COLUMN = 2  # 图片间隔，也就是合并成一张图后，一共有几列</span><br><span class="line">IMAGE_SAVE_PATH = &apos;###&apos;  # 图片转换后的地址</span><br><span class="line"></span><br><span class="line"># 获取图片集地址下的所有图片名称</span><br><span class="line">image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item]</span><br><span class="line">image_compose()  # 调用函数</span><br></pre></td></tr></table></figure><p><strong>2.2 python程序导入第三方库或模块</strong></p><ul><li>通过快捷键<em>Alt+Enter</em>或者<em>Ctrl+两次空格</em>；</li><li>可以通过命令行——<em>python  file.py</em> 来运行python程序，dos界面会提示却少的第三方库或模块，然后通过——<em>pip install  模块名</em>  命令来安装所需要的第三方库或模块。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、javaweb知识点总结&quot;&gt;&lt;a href=&quot;#一、javaweb知识点总结&quot; class=&quot;headerlink&quot; title=&quot;一、javaweb知识点总结&quot;&gt;&lt;/a&gt;一、javaweb知识点总结&lt;/h3&gt;&lt;h4 id=&quot;1-1-常见的java调
      
    
    </summary>
    
      <category term="项目总结" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jsp" scheme="http://yoursite.com/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>java垃圾回收机制</title>
    <link href="http://yoursite.com/2019/01/10/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/01/10/java垃圾回收机制/</id>
    <published>2019-01-10T10:00:04.000Z</published>
    <updated>2019-01-10T10:00:52.484Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面经" scheme="http://yoursite.com/categories/Java%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的索引</title>
    <link href="http://yoursite.com/2019/01/10/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/01/10/MySQL中的索引/</id>
    <published>2019-01-10T01:33:09.000Z</published>
    <updated>2019-01-10T08:06:34.253Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h3><h4 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h4><p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p><h4 id="1-2-为什么要建立索引？"><a href="#1-2-为什么要建立索引？" class="headerlink" title="1.2 为什么要建立索引？"></a>1.2 为什么要建立索引？</h4><p>如果没有索引，那么将从表中第一条记录一条条往下遍历，直到找到该条信息为止。<br>其中MySQL中的索引的存储类型有两种：BTREE、HASH。 也就是用树或者Hash值来存储该字段，就需要会算法的知识了。我们现在只需要知道索引的作用，功能是什么就行。</p><h3 id="二、MySQL中索引的优点和缺点和使用原则"><a href="#二、MySQL中索引的优点和缺点和使用原则" class="headerlink" title="二、MySQL中索引的优点和缺点和使用原则"></a>二、MySQL中索引的优点和缺点和使用原则</h3><h4 id="2-1-优点："><a href="#2-1-优点：" class="headerlink" title="2.1 优点："></a>2.1 优点：</h4><ul><li><p>所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引；</p></li><li><p>大大加快数据的查询速度。</p></li></ul><h4 id="2-2-缺点："><a href="#2-2-缺点：" class="headerlink" title="2.2 缺点："></a>2.2 缺点：</h4><ul><li>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加；</li><li>索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值；</li><li>当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</li></ul><h4 id="2-3-使用原则："><a href="#2-3-使用原则：" class="headerlink" title="2.3 使用原则："></a>2.3 使用原则：</h4><p>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。</p><ul><li><p>对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引；</p></li><li><p>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果；</p></li><li>在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ul><h3 id="三、索引的分类"><a href="#三、索引的分类" class="headerlink" title="三、索引的分类"></a>三、索引的分类</h3><p>注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。</p><ul><li><p>MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换；</p></li><li><p>MEMORY/HEAP存储引擎：支持HASH和BTREE索引。</p></li></ul><h4 id="3-1-索引类别"><a href="#3-1-索引类别" class="headerlink" title="3.1 索引类别"></a>3.1 索引类别</h4><p>单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、</p><h5 id="3-1-1-单列索引"><a href="#3-1-1-单列索引" class="headerlink" title="3.1.1 单列索引"></a>3.1.1 单列索引</h5><p>一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。</p><ul><li>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</li></ul><ul><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</li><li>主键索引：一种特殊的唯一索引，不允许有空值。</li></ul><h5 id="3-1-2-组合索引"><a href="#3-1-2-组合索引" class="headerlink" title="3.1.2 组合索引"></a>3.1.2 组合索引</h5><p>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说</p><h5 id="3-1-3-全文索引"><a href="#3-1-3-全文索引" class="headerlink" title="3.1.3 全文索引"></a>3.1.3 全文索引</h5><p>全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。</p><h5 id="3-1-4-空间索引"><a href="#3-1-4-空间索引" class="headerlink" title="3.1.4 空间索引"></a>3.1.4 空间索引</h5><ul><li>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。</li><li><p>在创建空间索引时，使用SPATIAL关键字。</p></li><li><p>要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、索引&quot;&gt;&lt;a href=&quot;#一、索引&quot; class=&quot;headerlink&quot; title=&quot;一、索引&quot;&gt;&lt;/a&gt;一、索引&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是索引？&quot;&gt;&lt;a href=&quot;#1-1-什么是索引？&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Java面经" scheme="http://yoursite.com/categories/Java%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间通信（IPC）</title>
    <link href="http://yoursite.com/2019/01/09/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/09/Linux进程间通信（IPC）/</id>
    <published>2019-01-09T13:52:51.000Z</published>
    <updated>2019-01-09T14:21:45.218Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、进程间通信概述"><a href="#一、进程间通信概述" class="headerlink" title="一、进程间通信概述"></a>一、进程间通信概述</h3><h4 id="1-1-进程通信目的："><a href="#1-1-进程通信目的：" class="headerlink" title="1.1 进程通信目的："></a>1.1 进程通信目的：</h4><h5 id="1-1-1-传输数据："><a href="#1-1-1-传输数据：" class="headerlink" title="1.1.1 传输数据："></a>1.1.1 传输数据：</h5><p>一个进程须要将它的数据发送给还有一个进程。发送的数据量在一个字节到几M字节之间</p><h5 id="1-1-2-共享数据"><a href="#1-1-2-共享数据" class="headerlink" title="1.1.2 共享数据"></a>1.1.2 共享数据</h5><p>多个进程想要操作共享数据。一个进程对共享数据的改动，别的进程应该立马看到。</p><h5 id="1-1-3-通知事件"><a href="#1-1-3-通知事件" class="headerlink" title="1.1.3 通知事件"></a>1.1.3 通知事件</h5><p>一个进程须要向还有一个或一组进程发送消息。通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p><h5 id="1-1-4-资源共享"><a href="#1-1-4-资源共享" class="headerlink" title="1.1.4 资源共享"></a>1.1.4 资源共享</h5><p>多个进程之间共享相同的资源。为了作到这一点，须要内核提供锁和同步机制。</p><h5 id="1-1-5-进程控制"><a href="#1-1-5-进程控制" class="headerlink" title="1.1.5 进程控制"></a>1.1.5 进程控制</h5><p>有些进程希望全然控制还有一个进程的运行（如Debug进程）。此时控制进程希望可以拦截还有一个进程的全部陷入和异常。并可以及时知道它的状态改变。</p><h4 id="1-2-本地的进程间通信（IPC）4种方式"><a href="#1-2-本地的进程间通信（IPC）4种方式" class="headerlink" title="1.2 本地的进程间通信（IPC）4种方式"></a>1.2 本地的进程间通信（IPC）4种方式</h4><p>A、消息传递（管道、FIFO、消息队列）<br>B、同步（相互排斥量、条件变量、读写锁、文件和写记录锁、信号量）<br>C、共享内存（匿名的和具名的）<br>D、远程过程调用（Solaris门和Sun RPC）</p><h3 id="二、linux下进程间通信的几种主要手段"><a href="#二、linux下进程间通信的几种主要手段" class="headerlink" title="二、linux下进程间通信的几种主要手段"></a>二、linux下进程间通信的几种主要手段</h3><h4 id="2-1-管道（Pipe）及有名管道（named-pipe）"><a href="#2-1-管道（Pipe）及有名管道（named-pipe）" class="headerlink" title="2.1 管道（Pipe）及有名管道（named pipe）"></a>2.1 管道（Pipe）及有名管道（named pipe）</h4><p>管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制。因此。除具有管道所具有的功能外，它还同意无亲缘关系进程间的通信；</p><h4 id="2-2-信号（Signal）"><a href="#2-2-信号（Signal）" class="headerlink" title="2.2 信号（Signal）"></a>2.2 信号（Signal）</h4><p>信号是比較复杂的通信方式。用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上。该函数是基于BSD的，BSD为了实现可靠信号机制，又可以统一对外接口，用sigaction函数又一次实现了signal函数）。</p><h4 id="2-3-消息（Message）队列"><a href="#2-3-消息（Message）队列" class="headerlink" title="2.3 消息（Message）队列"></a>2.3 消息（Message）队列</h4><p>消息队列是消息的链接表，包含Posix消息队列system V消息队列。有足够权限的进程能够向队列中加入消息。被赋予读权限的进程则能够读走队列中的消息。消息队列克服了信号承载信息量少，管道仅仅能承载无格式字节流以及缓冲区大小受限等缺点。</p><h4 id="2-4-共享内存"><a href="#2-4-共享内存" class="headerlink" title="2.4 共享内存"></a>2.4 共享内存</h4><p>使得多个进程能够訪问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制执行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及相互排斥。</p><h4 id="2-5-信号量（semaphore）"><a href="#2-5-信号量（semaphore）" class="headerlink" title="2.5 信号量（semaphore）"></a>2.5 信号量（semaphore）</h4><p>主要作为进程间以及同一进程不同线程之间的同步手段。</p><h4 id="2-6-套接口（Socket）"><a href="#2-6-套接口（Socket）" class="headerlink" title="2.6 套接口（Socket）"></a>2.6 套接口（Socket）</h4><p>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但如今一般能够移植到其他类Unix系统上：Linux和System V的变种都支持套接字。</p><p><strong>注：</strong></p><h5 id="Linux进程间通信"><a href="#Linux进程间通信" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h5><p> 管道、信号、信号量、消息队列、共享内存、套接字(socket)</p><h5 id="Linux线程间通信"><a href="#Linux线程间通信" class="headerlink" title="Linux线程间通信"></a>Linux线程间通信</h5><p>相互排斥量（mutex），信号量。条件变量</p><h5 id="Windows进程间通信"><a href="#Windows进程间通信" class="headerlink" title="Windows进程间通信"></a>Windows进程间通信</h5><p>管道、消息队列、共享内存、信号量 （semaphore） 、套接字(socket)</p><h5 id="Windows线程间通信"><a href="#Windows线程间通信" class="headerlink" title="Windows线程间通信"></a>Windows线程间通信</h5><p>相互排斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）</p><p><strong>[相关博文]:</strong></p><p><a href="https://blog.csdn.net/ds1130071727/article/details/78519527" target="_blank" rel="noopener">linux进程间通信(IPC)机制总结</a></p><p><a href="https://blog.csdn.net/a987073381/article/details/52006729" target="_blank" rel="noopener">linux基础——linux进程间通信（IPC）机制总结</a></p><p><a href="https://blog.csdn.net/xixihaha331/article/details/51425859" target="_blank" rel="noopener">Linux进程间通信 IPC机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、进程间通信概述&quot;&gt;&lt;a href=&quot;#一、进程间通信概述&quot; class=&quot;headerlink&quot; title=&quot;一、进程间通信概述&quot;&gt;&lt;/a&gt;一、进程间通信概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-进程通信目的：&quot;&gt;&lt;a href=&quot;#1-1-进程通信目
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令大全</title>
    <link href="http://yoursite.com/2019/01/09/linux/"/>
    <id>http://yoursite.com/2019/01/09/linux/</id>
    <published>2019-01-09T11:57:14.000Z</published>
    <updated>2019-01-09T14:15:12.903Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h3><p>本文总结了windows系统下git面板操作的常用命令，仅供参考学习。如果需要了解更多，请自行百科。</p><h3 id="二、常用Linux指令"><a href="#二、常用Linux指令" class="headerlink" title="二、常用Linux指令"></a>二、常用Linux指令</h3><h4 id="2-1-cd命令："><a href="#2-1-cd命令：" class="headerlink" title="2.1 cd命令："></a>2.1 cd命令：</h4><p><code>$ cd [path]   //path为路径名称，这只是常规语法</code></p><h5 id="2-1-1-详细用法如下："><a href="#2-1-1-详细用法如下：" class="headerlink" title="2.1.1 详细用法如下："></a>2.1.1 详细用法如下：</h5><p><code>$ cd /d     //进入d盘</code><br><code>$ cd d:     //进入d盘</code><br><code>$ cd D:     //进入d盘</code><br><code>$ cd /D     //进入d盘</code><br><code>$ cd ..       //返回上一级目录</code><br><code>$ cd ../      //返回上一级目录</code><br><code>$ cd ../../      //返回上两级目录</code><br><code>$ cd .        //切换到当前目录，通常没有任何反应</code><br><code>$ cd ./       //切换到当前目录，通常没有任何反应</code><br><code>$ cd          //不要以为看错了，确实就只有一个“cd”，它表示切换到个人主目录（类似于切换到window的桌面，但又不是桌面）</code><br><code>$ cd -       //返回上次访问目录（即倒退到上一次目录位置）</code><br><code>$ cd /d/loushengyue/study  //进入d盘中的loushengyue目录下的study目录</code></p><h4 id="2-2-ls命令："><a href="#2-2-ls命令：" class="headerlink" title="2.2 ls命令："></a>2.2 ls命令：</h4><p><code>$ ls      //查看当前目录中的文件夹及文件</code><br><code>$ ls -l   //查看当前目录下的文件和文件夹的详细资料</code><br><code>$ ls -a   //查看当前目录中的文件夹及文件(包括隐藏文件）</code><br><code>$ ls -la  //查看当前目录下的文件和文件夹的详细资料(包括隐藏文件）</code></p><h4 id="2-3-pwd命令："><a href="#2-3-pwd命令：" class="headerlink" title="2.3 pwd命令："></a>2.3 pwd命令：</h4><p><code>$ pwd  //显示当前目录路径</code></p><h4 id="2-4-rm命令："><a href="#2-4-rm命令：" class="headerlink" title="2.4 rm命令："></a>2.4 rm命令：</h4><p><code>$ rm test.js -rf      //删除当前目录下的 test.js 文件</code><br><code>$ rm ./test.html -rf  //删除当前目录下的 test.html 文件</code><br><code>$ rm ../test.css -rf  //删除上一级目录下的 test.css 文件</code><br><code>$ rm test/ -rf        //删除当前目录下的 test 文件夹</code><br><code>$ rm tst/tt.js -rf    //删除 tst 目录下的 tt.js 文件</code></p><h4 id="2-5-mkdir命令："><a href="#2-5-mkdir命令：" class="headerlink" title="2.5 mkdir命令："></a>2.5 mkdir命令：</h4><p><code>$ mkdir ./test          //在当前目录下创建 test 文件夹</code><br><code>$ mkdir ../test         //在上一级目录下创建 test 文件夹</code><br><code>$ mkdir ./test/son      //在当前目录下的 test 目录下创建 son 文件夹</code><br><code>$ mkdir ./tst1 ./tst2   //在当前目录下创建 tst1 和 tst2 文件夹</code></p><h4 id="2-6-mv命令："><a href="#2-6-mv命令：" class="headerlink" title="2.6 mv命令："></a>2.6 mv命令：</h4><p><code>$ mv dir new_dir       //当前目录下没有 new_dir 时表示将 dir 移动到当前目录下并重命名为 new_dir, 当前目录下有 new_dir 文件夹是表示将 dir 移动到 new_dir 目录中</code></p><h4 id="2-7-cp命令："><a href="#2-7-cp命令：" class="headerlink" title="2.7 cp命令："></a>2.7 cp命令：</h4><p><code>$ cp test.js newtest.js     //复制当前目录下的 test.js 到当前目录下并命名为 newtest.js</code><br><code>$ cp ../test.html ./        //复制上一级目录下的 test.html 到当前目录下（注意这里是./，没有重命名）</code></p><h4 id="2-8-touch命令："><a href="#2-8-touch命令：" class="headerlink" title="2.8 touch命令："></a>2.8 touch命令：</h4><p><code>$ touch ./test.js          //在当前目录下创建一个名为 test.js 的文件</code></p><p><strong>[相关博文]:</strong></p><p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5831284.html" target="_blank" rel="noopener">Linux常用命令大全</a></p><p><a href="https://www.cnblogs.com/caolisong/articles/741318.html" target="_blank" rel="noopener">linux常用命令大全</a></p><p><a href="https://www.cnblogs.com/Fairy-02-11/p/6196691.html" target="_blank" rel="noopener">Linux 常用命令大全</a></p><p><a href="https://www.cnblogs.com/zjh-ds/p/9576994.html" target="_blank" rel="noopener">linux命令大全</a></p><p><a href="https://www.cnblogs.com/Anderson-An/p/10146540.html" target="_blank" rel="noopener">Linux常用命令大全（非常全！！！）</a></p><p><a href="https://www.cnblogs.com/yyuyu/p/10014046.html" target="_blank" rel="noopener">这些Linux命令，让你的工作事半功倍！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、序言&quot;&gt;&lt;a href=&quot;#一、序言&quot; class=&quot;headerlink&quot; title=&quot;一、序言&quot;&gt;&lt;/a&gt;一、序言&lt;/h3&gt;&lt;p&gt;本文总结了windows系统下git面板操作的常用命令，仅供参考学习。如果需要了解更多，请自行百科。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="http://yoursite.com/2019/01/09/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/09/乐观锁和悲观锁/</id>
    <published>2019-01-09T11:51:51.000Z</published>
    <updated>2019-01-10T09:30:37.483Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java面经" scheme="http://yoursite.com/categories/Java%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LOF离群点检测</title>
    <link href="http://yoursite.com/2019/01/09/LOF%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/01/09/LOF离群点检测/</id>
    <published>2019-01-09T11:51:39.000Z</published>
    <updated>2019-01-10T09:28:23.697Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="http://yoursite.com/2019/01/09/spring/"/>
    <id>http://yoursite.com/2019/01/09/spring/</id>
    <published>2019-01-09T11:50:14.000Z</published>
    <updated>2019-01-09T12:00:31.731Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://yoursite.com/2019/01/09/mybatis/"/>
    <id>http://yoursite.com/2019/01/09/mybatis/</id>
    <published>2019-01-09T11:49:21.000Z</published>
    <updated>2019-01-09T11:59:39.441Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java排序算法</title>
    <link href="http://yoursite.com/2019/01/09/java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/09/java排序算法/</id>
    <published>2019-01-09T09:15:25.000Z</published>
    <updated>2019-01-10T09:31:10.847Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><h4 id="1-1-快速排序的基本思想："><a href="#1-1-快速排序的基本思想：" class="headerlink" title="1.1 快速排序的基本思想："></a>1.1 快速排序的基本思想：</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="1-2-冒泡排序的示例："><a href="#1-2-冒泡排序的示例：" class="headerlink" title="1.2 冒泡排序的示例："></a>1.2 冒泡排序的示例：</h4><p><img src="https://img-blog.csdnimg.cn/20181206114143449.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="1-3-冒泡排序的算法实现如下-【排序后，数组从小到大排列】"><a href="#1-3-冒泡排序的算法实现如下-【排序后，数组从小到大排列】" class="headerlink" title="1.3 冒泡排序的算法实现如下:【排序后，数组从小到大排列】"></a>1.3 冒泡排序的算法实现如下:【排序后，数组从小到大排列】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。   </span><br><span class="line">   * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  </span><br><span class="line">   * 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line">   * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br><span class="line">   * @param numbers 需要排序的整型数组</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public static void bubbleSort(int[] numbers) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int size = numbers.length;</span><br><span class="line">    for(int i = 0 ; i &lt; size-1; i ++) &#123;</span><br><span class="line">       for(int j = 0 ;j &lt; size-1-i ; j++) &#123;</span><br><span class="line">          if(numbers[j] &gt; numbers[j+1]) &#123;   //交换两数位置</span><br><span class="line">           temp = numbers[j];</span><br><span class="line">           numbers[j] = numbers[j+1];</span><br><span class="line">           numbers[j+1] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h3><h4 id="2-1-快速排序的基本思想："><a href="#2-1-快速排序的基本思想：" class="headerlink" title="2.1 快速排序的基本思想："></a>2.1 快速排序的基本思想：</h4><p>通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则分别对这两部分继续进行排序，直到整个序列有序。</p><h4 id="2-2-快速排序的示例："><a href="#2-2-快速排序的示例：" class="headerlink" title="2.2 快速排序的示例："></a>2.2 快速排序的示例：</h4><h5 id="2-2-1-一趟排序的过程："><a href="#2-2-1-一趟排序的过程：" class="headerlink" title="2.2.1 一趟排序的过程："></a>2.2.1 一趟排序的过程：</h5><p><img src="https://img-blog.csdnimg.cn/20181206114630379.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-2-2-排序的全过程："><a href="#2-2-2-排序的全过程：" class="headerlink" title="2.2.2 排序的全过程："></a>2.2.2 排序的全过程：</h5><p><img src="https://img-blog.csdnimg.cn/20181206114652417.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>把整个序列看做一个数组，把第零个位置看做中轴，和最后一个比，如果比它小交换，比它大不做任何处理；交换了以后再和小的那端比，比它小不交换，比他大交换。这样循环往复，一趟排序完成，左边就是比中轴小的，右边就是比中轴大的，然后再用分治法，分别对这两个独立的数组进行排序。</p><h4 id="2-3-代码实现如下："><a href="#2-3-代码实现如下：" class="headerlink" title="2.3 代码实现如下："></a>2.3 代码实现如下：</h4><h5 id="2-3-1-查找中轴（最低位作为中轴）所在位置："><a href="#2-3-1-查找中轴（最低位作为中轴）所在位置：" class="headerlink" title="2.3.1 查找中轴（最低位作为中轴）所在位置："></a>2.3.1 查找中轴（最低位作为中轴）所在位置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置</span><br><span class="line">   * @param numbers 待查找数组</span><br><span class="line">   * @param low   开始位置</span><br><span class="line">   * @param high  结束位置</span><br><span class="line">   * @return  中轴所在位置</span><br><span class="line">*/</span><br><span class="line">public static int getMiddle(int[] numbers, int low,int high) &#123;</span><br><span class="line">      int temp = numbers[low];              //数组的第一个作为中轴</span><br><span class="line">      while(low &lt; high) &#123;</span><br><span class="line">       while(low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123;</span><br><span class="line">           high--;</span><br><span class="line">       &#125;</span><br><span class="line">        numbers[low] = numbers[high];    //比中轴小的记录移到低端</span><br><span class="line">       while(low &lt; high &amp;&amp; numbers[low] &lt; temp)&#123;</span><br><span class="line">           low++;</span><br><span class="line">       &#125;</span><br><span class="line">       numbers[high] = numbers[low] ;       //比中轴大的记录移到高端</span><br><span class="line">      &#125;</span><br><span class="line">      numbers[low] = temp ;                  //中轴记录到尾</span><br><span class="line">      return low ;                           // 返回中轴的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-递归形式的分治排序算法："><a href="#2-3-2-递归形式的分治排序算法：" class="headerlink" title="2.3.2 递归形式的分治排序算法："></a>2.3.2 递归形式的分治排序算法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @param numbers 带排序数组</span><br><span class="line">   * @param low  开始位置</span><br><span class="line">   * @param high 结束位置</span><br><span class="line">*/</span><br><span class="line">public static void quickSort(int[] numbers,int low,int high)&#123;</span><br><span class="line"> if(low &lt; high)&#123;</span><br><span class="line">    int middle = getMiddle(numbers,low,high); //将numbers数组进行一分为二</span><br><span class="line">    quickSort(numbers, low, middle-1);  //对低字段表进行递归排序</span><br><span class="line">    quickSort(numbers, middle+1, high); //对高字段表进行递归排序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-快速排序提供方法调用："><a href="#2-3-3-快速排序提供方法调用：" class="headerlink" title="2.3.3 快速排序提供方法调用："></a>2.3.3 快速排序提供方法调用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * @param numbers 带排序数组</span><br><span class="line">*/</span><br><span class="line">public static void quick(int[] numbers)&#123;</span><br><span class="line">    if(numbers.length &gt; 0) &#123;  //查看数组是否为空</span><br><span class="line">        quickSort(numbers, 0, numbers.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-分析："><a href="#2-4-分析：" class="headerlink" title="2.4 分析："></a>2.4 分析：</h4><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><h4 id="2-5-方法测试："><a href="#2-5-方法测试：" class="headerlink" title="2.5 方法测试："></a>2.5 方法测试：</h4><h5 id="2-5-1-打印函数："><a href="#2-5-1-打印函数：" class="headerlink" title="2.5.1 打印函数："></a>2.5.1 打印函数：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void printArr(int[] numbers) &#123;</span><br><span class="line">     for(int i = 0 ; i &lt; numbers.length ; i ++ ) &#123;</span><br><span class="line">       System.out.print(numbers[i] + &quot;,&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-2-测试："><a href="#2-5-2-测试：" class="headerlink" title="2.5.2 测试："></a>2.5.2 测试：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] numbers = &#123;10,20,15,0,6,7,2,1,-5,55&#125;;</span><br><span class="line">    System.out.print(&quot;排序前：&quot;);</span><br><span class="line">    printArr(numbers);</span><br><span class="line">    bubbleSort(numbers);</span><br><span class="line">    System.out.print(&quot;冒泡排序后：&quot;);</span><br><span class="line">    printArr(numbers);</span><br><span class="line">    quick(numbers);</span><br><span class="line">    System.out.print(&quot;快速排序后：&quot;);</span><br><span class="line">    printArr(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-3-结果："><a href="#2-5-3-结果：" class="headerlink" title="2.5.3 结果："></a>2.5.3 结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排序前：10,20,15,0,6,7,2,1,-5,55,</span><br><span class="line">冒泡排序后：-5,0,1,2,6,7,10,15,20,55,</span><br><span class="line">快速排序后：-5,0,1,2,6,7,10,15,20,55,</span><br></pre></td></tr></table></figure><h3 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h3><h4 id="3-1-基本思想："><a href="#3-1-基本思想：" class="headerlink" title="3.1 基本思想："></a>3.1 基本思想：</h4><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p><h4 id="3-2-实例"><a href="#3-2-实例" class="headerlink" title="3.2 实例"></a>3.2 实例</h4><p><img src="https://img-blog.csdnimg.cn/20181206161535430.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-3-算法实现"><a href="#3-3-算法实现" class="headerlink" title="3.3 算法实现"></a>3.3 算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 选择排序算法</span><br><span class="line">   * 在未排序序列中找到最小元素，存放到排序序列的起始位置  </span><br><span class="line">   * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 </span><br><span class="line">   * 以此类推，直到所有元素均排序完毕。 </span><br><span class="line">   * @param numbers</span><br><span class="line">*/</span><br><span class="line">public static void selectSort(int[] numbers)&#123;</span><br><span class="line">   int size = numbers.length; //数组长度</span><br><span class="line">   int temp = 0 ; //中间变量</span><br><span class="line">    for(int i = 0 ; i &lt; size ; i++)&#123;</span><br><span class="line">    int k = i;   //待确定的位置</span><br><span class="line">    //选择出应该在第i个位置的数</span><br><span class="line">    for(int j = size -1 ; j &gt; i ; j--)&#123;</span><br><span class="line">    if(numbers[j] &lt; numbers[k])&#123;</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //交换两个数</span><br><span class="line">    temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[k];</span><br><span class="line">    numbers[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a>四、插入排序</h3><h4 id="4-1-基本思想"><a href="#4-1-基本思想" class="headerlink" title="4.1 基本思想"></a>4.1 基本思想</h4><p>每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。</p><h4 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4.2 实例"></a>4.2 实例</h4><p><img src="https://img-blog.csdnimg.cn/20181206161831220.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-3-算法实现"><a href="#4-3-算法实现" class="headerlink" title="4.3 算法实现"></a>4.3 算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line">   * 从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">   * 取出下一个元素，在已经排序的元素序列中从后向前扫描 </span><br><span class="line">   * 如果该元素（已排序）大于新元素，将该元素移到下一位置  </span><br><span class="line">   * 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置  </span><br><span class="line">   * 将新元素插入到该位置中  </span><br><span class="line">   * 重复步骤2  </span><br><span class="line">   * @param numbers  待排序数组</span><br><span class="line">*/  </span><br><span class="line">public static void insertSort(int[] numbers)&#123;</span><br><span class="line">int size = numbers.length;</span><br><span class="line">int temp = 0 ;</span><br><span class="line">int j =  0;  </span><br><span class="line"></span><br><span class="line">for(int i = 0 ; i &lt; size ; i++)&#123;</span><br><span class="line">temp = numbers[i];</span><br><span class="line">    //假如temp比前面的值小，则将前面的值后移</span><br><span class="line">    for(j = i ; j &gt; 0 &amp;&amp; temp &lt; numbers[j-1] ; j --)&#123;</span><br><span class="line">    numbers[j] = numbers[j-1];</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-效率："><a href="#4-4-效率：" class="headerlink" title="4.4 效率："></a>4.4 效率：</h4><p>时间复杂度：O（n^2）。</p><h3 id="五、希尔算法"><a href="#五、希尔算法" class="headerlink" title="五、希尔算法"></a>五、希尔算法</h3><h4 id="5-1-基本思想："><a href="#5-1-基本思想：" class="headerlink" title="5.1 基本思想："></a>5.1 基本思想：</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="5-2-操作方法："><a href="#5-2-操作方法：" class="headerlink" title="5.2 操作方法："></a>5.2 操作方法：</h4><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p>希尔排序的示例：</p><p><img src="https://img-blog.csdnimg.cn/20181206163250884.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-3-算法实现："><a href="#5-3-算法实现：" class="headerlink" title="5.3 算法实现："></a>5.3 算法实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 希尔排序的原理:根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值；</span><br><span class="line">   * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，可以说希尔排序是加强版的插入排序；</span><br><span class="line">   * 拿数组5, 2, 8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较，此例子是按照从大到小排列，所以大的会排在前面，第一次排序后数组为9, 2, 8, 5, 1, 3，4；</span><br><span class="line">   * 第一次后increment的值变为3/2=1,此时对数组进行插入排序，实现数组从大到小排。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public static void shellSort(int[] data)&#123;</span><br><span class="line">      int j = 0;</span><br><span class="line">      int temp = 0;</span><br><span class="line">      //每次将步长缩短为原来的一半</span><br><span class="line">      for (int increment = data.length / 2; increment &gt; 0;increment /= 2)&#123;</span><br><span class="line">      for (int i = increment; i &lt; data.length; i++) &#123;</span><br><span class="line">          temp = data[i];</span><br><span class="line">          for (j = i; j &gt;= increment; j -= increment) &#123;</span><br><span class="line">          if(temp &gt; data[j - increment])&#123;  //如想从小到大排只需修改这里</span><br><span class="line">              data[j] = data[j - increment];</span><br><span class="line">              &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">              break;</span><br><span class="line">              &#125;      </span><br><span class="line">&#125; </span><br><span class="line">      data[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-效率"><a href="#5-4-效率" class="headerlink" title="5.4 效率"></a>5.4 效率</h4><p>时间复杂度：O（n^2）.</p><h3 id="六、归并排序算法"><a href="#六、归并排序算法" class="headerlink" title="六、归并排序算法"></a>六、归并排序算法</h3><h4 id="6-1-基本思想："><a href="#6-1-基本思想：" class="headerlink" title="6.1 基本思想："></a>6.1 基本思想：</h4><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><h4 id="6-2-归并排序示例："><a href="#6-2-归并排序示例：" class="headerlink" title="6.2 归并排序示例："></a>6.2 归并排序示例：</h4><p><img src="https://img-blog.csdnimg.cn/20181206163601405." alt="在这里插入图片描述"></p><h4 id="6-3-合并方法："><a href="#6-3-合并方法：" class="headerlink" title="6.3 合并方法："></a>6.3 合并方法：</h4><p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i +1、n-m。</p><p><strong>a).</strong> j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标；<br><strong>b).</strong> 若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束；<br><strong>c).</strong> 选取r[i]和r[j]较小的存入辅助数组rf；</p><ul><li><p>如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵；</p></li><li><p>否则，rf[k]=r[j]； j++； k++； 转⑵</p></li></ul><p><strong>d).</strong> 将尚未处理完的子表中元素存入rf；</p><ul><li>如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空；</li><li>如果j&lt;=n , 将r[j…n] 存入rf[k…n] //后一子表非空</li></ul><p><strong>e).</strong> 合并结束。</p><h4 id="6-4-算法实现："><a href="#6-4-算法实现：" class="headerlink" title="6.4 算法实现："></a>6.4 算法实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">   * 归并排序</span><br><span class="line">   * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列</span><br><span class="line">   * 时间复杂度为O(nlogn)</span><br><span class="line">   * 稳定排序方式</span><br><span class="line">   * @param nums 待排序数组</span><br><span class="line">   * @return 输出有序数组</span><br><span class="line">*/</span><br><span class="line">public static int[] sort(int[] nums, int low, int high) &#123;</span><br><span class="line">      int mid = (low + high) / 2;</span><br><span class="line">      if (low &lt; high) &#123;</span><br><span class="line">          // 左边</span><br><span class="line">          sort(nums, low, mid);</span><br><span class="line">          // 右边</span><br><span class="line">          sort(nums, mid + 1, high);</span><br><span class="line">          // 左右归并</span><br><span class="line">          merge(nums, low, mid, high);</span><br><span class="line">      &#125;</span><br><span class="line">      return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * 将数组中low到high位置的数进行排序</span><br><span class="line">   * @param nums 待排序数组</span><br><span class="line">   * @param low 待排的开始位置</span><br><span class="line">   * @param mid 待排中间位置</span><br><span class="line">   * @param high 待排结束位置</span><br><span class="line">*/</span><br><span class="line">public static void merge(int[] nums, int low, int mid, int high) &#123;</span><br><span class="line">int[] temp = new int[high - low + 1];</span><br><span class="line">int i = low;// 左指针</span><br><span class="line">int j = mid + 1;// 右指针</span><br><span class="line">int k = 0;</span><br><span class="line">    // 把较小的数先移到新数组中</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">    if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把左边剩余的数移入数组</span><br><span class="line">while (i &lt;= mid) &#123;</span><br><span class="line">    temp[k++] = nums[i++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把右边边剩余的数移入数组</span><br><span class="line">while (j &lt;= high) &#123;</span><br><span class="line">    temp[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把新数组中的数覆盖nums数组</span><br><span class="line">for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">    nums[k2 + low] = temp[k2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、堆排序算法"><a href="#七、堆排序算法" class="headerlink" title="七、堆排序算法"></a>七、堆排序算法</h3><h4 id="7-1-基本思想："><a href="#7-1-基本思想：" class="headerlink" title="7.1 基本思想："></a>7.1 基本思想：</h4><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p><ul><li>堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二 叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。</li></ul><ul><li>思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</li></ul><h4 id="7-2-实例"><a href="#7-2-实例" class="headerlink" title="7.2 实例"></a>7.2 实例</h4><p>初始序列：46, 79, 56, 38, 40, 8</p><h5 id="1）建堆："><a href="#1）建堆：" class="headerlink" title="1）建堆："></a>1）建堆：</h5><p><img src="https://img-blog.csdnimg.cn/20181206164038764.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2）交换，从堆中踢出最大数"><a href="#2）交换，从堆中踢出最大数" class="headerlink" title="2）交换，从堆中踢出最大数"></a>2）交换，从堆中踢出最大数</h5><p><img src="https://img-blog.csdnimg.cn/20181206164119809.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3）依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。"><a href="#3）依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。" class="headerlink" title="3）依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。"></a>3）依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。</h5><h4 id="7-3-算法实现："><a href="#7-3-算法实现：" class="headerlink" title="7.3 算法实现："></a>7.3 算法实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a=&#123;49,38,65,97,76,13,27,49,78,34,12,64&#125;;</span><br><span class="line">        int arrayLength=a.length;  </span><br><span class="line">        //循环建堆  </span><br><span class="line">        for(int i=0;i&lt;arrayLength-1;i++)&#123;  </span><br><span class="line">            //建堆  </span><br><span class="line">            buildMaxHeap(a,arrayLength-1-i);  </span><br><span class="line">            //交换堆顶和最后一个元素  </span><br><span class="line">           swap(a,0,arrayLength-1-i);  </span><br><span class="line">           System.out.println(Arrays.toString(a));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    //对data数组从0到lastIndex建大顶堆</span><br><span class="line">    public static void buildMaxHeap(int[] data, int lastIndex)&#123;</span><br><span class="line">        //从lastIndex处节点（最后一个节点）的父节点开始 </span><br><span class="line">        for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123;</span><br><span class="line">            //k保存正在判断的节点 </span><br><span class="line">            int k=i;</span><br><span class="line">            //如果当前k节点的子节点存在  </span><br><span class="line">            while(k*2+1&lt;=lastIndex)&#123;</span><br><span class="line">                //k节点的左子节点的索引 </span><br><span class="line">                int biggerIndex=2*k+1;</span><br><span class="line">                //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span><br><span class="line">                if(biggerIndex&lt;lastIndex)&#123;  </span><br><span class="line">                    //若果右子节点的值较大  </span><br><span class="line">                    if(data[biggerIndex]&lt;data[biggerIndex+1])&#123;  </span><br><span class="line">                        //biggerIndex总是记录较大子节点的索引  </span><br><span class="line">                        biggerIndex++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                //如果k节点的值小于其较大的子节点的值  </span><br><span class="line">                if(data[k]&lt;data[biggerIndex])&#123;  </span><br><span class="line">                    //交换他们  </span><br><span class="line">                    swap(data,k,biggerIndex);  </span><br><span class="line">                    //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值  </span><br><span class="line">                    k=biggerIndex;  </span><br><span class="line">                &#125;else&#123;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //交换</span><br><span class="line">    private static void swap(int[] data, int i, int j) &#123;  </span><br><span class="line">        int tmp=data[i];  </span><br><span class="line">        data[i]=data[j];  </span><br><span class="line">        data[j]=tmp;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、各种算法的时间复杂度"><a href="#八、各种算法的时间复杂度" class="headerlink" title="八、各种算法的时间复杂度"></a>八、各种算法的时间复杂度</h3><p><img src="https://img-blog.csdnimg.cn/20181206164312680.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTI1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>[相关博文]:</strong></p><p><a href="https://blog.csdn.net/u010983881/article/details/76383527" target="_blank" rel="noopener">八大<em>排序算法</em>总结与<em>java实现</em></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、冒泡排序&quot;&gt;&lt;a href=&quot;#一、冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;一、冒泡排序&quot;&gt;&lt;/a&gt;一、冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;1-1-快速排序的基本思想：&quot;&gt;&lt;a href=&quot;#1-1-快速排序的基本思想：&quot; cl
      
    
    </summary>
    
      <category term="Java面经" scheme="http://yoursite.com/categories/Java%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>windows常用命令行</title>
    <link href="http://yoursite.com/2019/01/09/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://yoursite.com/2019/01/09/windows常用命令行/</id>
    <published>2019-01-09T09:15:25.000Z</published>
    <updated>2019-01-16T10:28:21.215Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="1-用set-password命令："><a href="#1-用set-password命令：" class="headerlink" title="1. 用set password命令："></a>1. 用set password命令：</h4><p><code>mysql -u root</code><br><code>mysql&gt; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;newpass&#39;);</code></p><h4 id="2-查看端口号："><a href="#2-查看端口号：" class="headerlink" title="2. 查看端口号："></a>2. 查看端口号：</h4><h5 id="netstat-ano"><a href="#netstat-ano" class="headerlink" title="netstat -ano"></a><code>netstat -ano</code></h5><h4 id="3-连接远程服务器："><a href="#3-连接远程服务器：" class="headerlink" title="3. 连接远程服务器："></a>3. 连接远程服务器：</h4><p><code>mstsc</code></p><h4 id="4-查看本机ip地址："><a href="#4-查看本机ip地址：" class="headerlink" title="4. 查看本机ip地址："></a>4. 查看本机ip地址：</h4><p><code>ipconfig/all</code></p><h4 id="5-将mysql所有权赋予root账户："><a href="#5-将mysql所有权赋予root账户：" class="headerlink" title="5. 将mysql所有权赋予root账户："></a>5. 将mysql所有权赋予root账户：</h4><p><code>grant select,update,insert,delete on *.* to root@127.0.0.1 identified by &quot;root&quot;;</code></p><h4 id="6-使操作生效："><a href="#6-使操作生效：" class="headerlink" title="6. 使操作生效："></a>6. 使操作生效：</h4><p><code>flush privileges</code></p><h4 id="7-创建账户root，密码为root："><a href="#7-创建账户root，密码为root：" class="headerlink" title="7. 创建账户root，密码为root："></a>7. 创建账户root，密码为root：</h4><p><code>create user &#39;root&#39; identified by &#39;root&#39;；</code></p><h4 id="8-打开服务："><a href="#8-打开服务：" class="headerlink" title="8. 打开服务："></a>8. 打开服务：</h4><p><code>services.msc</code></p><h4 id="9-连接远端或本地ip-端口号："><a href="#9-连接远端或本地ip-端口号：" class="headerlink" title="9. 连接远端或本地ip 端口号："></a>9. 连接远端或本地ip 端口号：</h4><p><code>telnet IP 端口号</code><br><code>Ctrl+]  回车（显示回显）</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;1-用set-password命令：&quot;&gt;&lt;a href=&quot;#1-用set-password命令：&quot; class=&quot;headerlink&quot; title=&quot;1. 用set password命令：&quot;&gt;&lt;/a&gt;1. 用set password命令：&lt;/h4&gt;&lt;p
      
    
    </summary>
    
      <category term="windows" scheme="http://yoursite.com/categories/windows/"/>
    
    
      <category term="dos" scheme="http://yoursite.com/tags/dos/"/>
    
  </entry>
  
  <entry>
    <title>Hexo命令</title>
    <link href="http://yoursite.com/2019/01/09/Hexo%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/01/09/Hexo命令/</id>
    <published>2019-01-09T07:46:19.000Z</published>
    <updated>2019-01-09T14:16:50.891Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="1-常用hexo命令"><a href="#1-常用hexo命令" class="headerlink" title="1. 常用hexo命令"></a>1. 常用hexo命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h4 id="2-缩写："><a href="#2-缩写：" class="headerlink" title="2. 缩写："></a>2. 缩写：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><h4 id="3-组合命令："><a href="#3-组合命令：" class="headerlink" title="3. 组合命令："></a>3. 组合命令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h4 id=&quot;1-常用hexo命令&quot;&gt;&lt;a href=&quot;#1-常用hexo命令&quot; class=&quot;headerlink&quot; title=&quot;1. 常用hexo命令&quot;&gt;&lt;/a&gt;1. 常用hexo命令&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="GitHub" scheme="http://yoursite.com/categories/GitHub/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
